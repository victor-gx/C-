# 补充知识、线程池浅谈、数量谈与总结

## 知识点补充

### 虚假唤醒

前面比较详细地讲述了条件变量 `condition_variable `、`wait` 、`notify_one` 与 `notify_all` 的用法，请读者认真学习和思考，充分理解 `wait `、`notify_one`、`notify_all`的工作细节，因为它们可能在日后的C++11多线程编程中被频繁使用。

回顾一下之前的代码：

```c++
class A
{
public:
    // 把收到的消息(玩家命令)放入到一个队列的线程
    void inMsgRecvQueue()
    {
        for (int i = 0; i < 100000; ++i)
        {
            cout << "inMsgRecvQueue()执行,插入一个元素" << i << endl;
            std::unique_lock<std::mutex> sbguard1(my_mutex);
            msgRecvQueue.push_back(i); // 假设这个数字就是收到的命令,则将其直接放到消息//队列里
            my_cond.notify_one();      // 尝试把卡(堵塞)在 wait( )的线程唤醒,但光唤醒了还不够, //这里必须把互斥量解锁，另外一个线程的wait()才会继续正//常工作
        }
        return;
    }
    // 把数据从消息队列中取出的线程
    void outMsgRecvQueue()
    {
        int command = 0;
        while (true)
        {
            std::unique_lock<std::mutex> sbguard1(my_mutex); // 临界进去
            my_cond.wait(sbguard1, [this] {
                if(!msgRecvQueue. empty())
                return true;
                return false; 
            });
            // 现在互斥量是锁着的，流程走下来意味着msgRecvQueue队列里必然有数据
            command = msgRecvQueue.front(); // 返回第一个元素，但不检查元素是否存在
            msgRecvQueue.pop_front();       // 移除第一个元素，但不返回
            sbguard1.unlock();              // 因为 unique_lock 的灵活性,可以随时 unlock 解锁,以免锁住太//长时间
            cout << "outMsgRecvQueue()执行,取出一个元素" << command << " threadid =" << std::this_thread::get_id() << endl;
        } // end while
    }

private:
    std::list<int> msgRecvQueue; // 容器(消息队列)
    std:: mutex my_mutex; //创建了一个互斥量(一把锁头)
    std::condition_variable my_cond; // 生成一个条件对象
};
```

`main`主函数代码如下：

```c++
int main()
{
    A myobja;
    std::thread myOutnMsgObj(&A::outMsgRecvQueue, &myobja); // 第二个参数是引用(地址),才能
    // 保证线程里用的是同一个对象
    std::thread myInMsgObj(&A::inMsgRecvQueue, &myobja);
    myInMsgObj.join();
    myOutnMsgObj.join();
    cout << "main主函数执行结束!" << endl;
    return 0;
}
```

执行起来，一切正常。

在这里提及一个概念，叫作“虚假唤醒”。

虚假唤醒，就是`wait`代码行被唤醒了，但是不排除`msgRecvQueue`(消息队列)里面没有数据的情形。醒来是为了处理数据，但是实际没有可供处理的数据，这就叫虚假唤醒。

虚假唤醒产生的情况很多，例如` push_back` 一条数据，调用多次`notify_one`，或者是有多个`outMsgRecvQueue`线程取数据，但是`inMsgRecvQueue`线程里只 `push_back `了一条数据，然后用 `notify_all` 把所有的`outMsgRecvQueue`线程都通知到了，就总有某个`outMsgRecvQueue`线程被唤醒，但是队列中并没有它要处理的数据。

现在读者看到的代码已经把虚假唤醒处理得很好，笔者在这里只是介绍“虚假唤醒”的概念而已，防止日后听到这个概念感觉陌生。那代码是怎样处理虚假唤醒的呢?就是下面这段代码(`if` 语句所在行)：

```c++
my_cond.wait(sbguard1, [this] {
    if (!msgRecvQueue.empty())
        return true; // 该lambda表达式返回true,则wait就返回,流程走下来,互斥锁被本线程拿到return 		false; //解锁并休眠，卡在wait等待被再次唤醒
});
```

所以请注意，` wait`的第二个参数(lambda表达式)特别重要，通过里面的`if`判断语句来应付虚假唤醒。因为`wait`被唤醒后，是要先拿锁，拿到锁后才会执行这个lambda表达式中的判断语句，所以此时这个lambda表达式里面的判断是安全的。

另外已经知道，对于`wait`，如果一直不`notify`或者`notify`的时机不对，可能唤醒不了`wait`，这就会导致一直卡在` wait `行，所以在书写使用` condition_variable `、`wait`、`notify_one`、`notify_all`的代码时，要透彻理解，小心测试，以免不小心写出错误代码，而且一旦出现错误，比较难排查。

建议读者找一些知名的代码，并详细剖析，理解其工作的稳定性如何，总结出一套属于自己的稳定好用的多线程代码库，方便在实际工作中随时取用。

### atomic的进一步理解

atomic表示原子操作，前面已经有过详细的介绍。

在`lesson12.cpp`的开头包含下列头文件:

```c++
#include <atomic>
```

在类`A`中增加成员变量如下：

```c++
atomic<int> atm;
```

在类`A`的构造函数中给这个成员变量初值：

```c++
public:
    A() // 构造函数
    {
        atm = 0;
    }
```

现在把`inMsgRecvQueue`和`outMsgRecvQueue`这两个类`A`的成员函数(也是线程入口函数)原有内容全部注释掉，写入新内容。写入新内容后的两个成员函数如下：

```c++
void inMsgRecvQueue()
{
    for (int i = 0; i < 1000000; ++i)
    {
        atm += 1; // 原子操作
    }
    return;
}
void outMsgRecvQueue()
{
    while (true)
    {
        cout << atm << endl;
    }
}
```

执行起来，一切正常，最终的输出结果始终是1000000(虽然程序写得很差，还用到了死循环，但执行结果并没有什么问题)。

现在以`inMsgRecvQueue`为线程入口函数，再创建一个新的线程，这只需要修改main主函数即可做到。修改后的`main`主函数代码如下：

```c++
A myobja;
std::thread myOutnMsgObj(&A::outMsgRecvQueue, &myobja);
std::thread myInMsgObj(&A::inMsgRecvQueue, &myobja);
std::thread myInMsgObj2(&A::inMsgRecvQueue, &myobja);
myInMsgObj.join();
myInMsgObj2.join();
myOutnMsgObj.join();
cout << "main 主函数执行结束!" << endl;
```

执行起来，一切正常，最终的输出结果始终是2000000。

现在修改`inMsgRecvQueue`线程入口函数。修改之后的代码如下：

```c++
void inMsgRecvQueue()
{
    for (int i = 0; i < 1000000; ++i)
    {
        atm = atm + 1; // 非原子操作
    }
    return;
}
```

执行起来，最终的输出结果就会小于2000000。因为有两个`inMsgRecvQueue`线程来同时改写`atm`的值，但`atm = atm + 1;`这行代码却不是原子操作。所以，导致最终的结果是错的。

那么，outMsgRecvQueue线程中的如下这行代码,怎样理解呢?

```c++
cout << atm << endl;
```

上面这行代码出现了`atm`，表示要读`atm`的值，读该值是原子操作，但是这可是整个一行语句，这整个一行语句却不是原子操作。

`<<`是把`atm`的值往屏幕上输出，可能输出的同时，其他`inMsgRecvQueue`线程又已经改变了`atm`的值。换句话说，此时此刻屏幕上输出的值应该是一个`atm`的曾经值。当然，最后当`atm`不再继续增加的时候，在屏幕上输出的会是`atm`的最终值，此后`atm`的输出结果就会一直保持不变。

随便找个位置试一下下面这行代码，例如在类`A`的构造函数中写入：

```c++
auto atm2 = atm; //不允许，编译时报语法错
```

编译的时候系统会报错，提示的错误诸如`std::atomic <int>::atomic(const std::atomic<int>&)`尝试引用已删除的函数。

分析一下，上面这行代码会调用`atomic`的拷贝构造函数，这里提到的已删除的函数应该指的就是拷贝构造函数。

为什么编译器不让其进行复制构造呢?因为这里如果允许这样给值，那`auto`推断也会推断成`atomic<int>`类型，因为`atomic`对象是原子的，上面这种“定义时初始化的语句”肯定很难弄成原子操作，所以系统处理的方式很简单直接，干脆不让用拷贝构造函数来构造新的`atomic`对象。

同理，复制赋值运算符也不可以使用。下面的代码也不合法：

```c++
atomic<int> atm3;
atm3 = atm; //不允许，编译时报语法错
```

既然复制构造不可以，复制赋值也不行，那如何实现类似的功能呢? `atomic`提供了一些成员函数能够做类似的事情。

1. `load`——以原子方式读`atomic`对象的值：

   ```c++
   atomic<int> atm5(atm.load()); //这是可以的
   ```

2. `store`——以原子的方式写入内容：

   ```c++
   atm5.store(12);
   ```

那么，`atm5 = 12;`这种代码是否是原子操作呢?通过一定的调试观察，感觉这种赋值内部调用的也是 `store`成员函数。所以`atm5 = 12;`我也是原子操作，与`atm5.store(12);`似乎没有什么本质差异。

如果说到`store`、`load`的性能问题，不好说，当然，毕竟是`atomic`对象，和非`atomic`对象比，性能上肯定是差一些。如果有条件或者大量使用`store`、`load`的话，可以考虑专门测试一下它们的效率问题。

## 浅谈线程池

### 场景设想

设想这样一个场景：开发一个服务器程序，等待客户端连接进来。每进来一个客户端连接，这个服务器程序就创建一个新的工作线程，专门给这个客户端提供服务，客户离开或者断线后，这个工作线程就执行结束。

这种服务器实现方式可能写起代码来比较简单，但是也有明显的缺陷。例如，如果客户端只有10个20个的数量，每个客户创建1个线程当然没问题，也就是说负荷最高的时候这个服务器程序中同时运行的线程数量也不过是20个，这种资源消耗可以说任何计算机硬件都能应付。但有两个问题必须思考：

1. 如果是一个网络游戏，玩家特别多，如果这一个服务程序上同时有2万个玩家客户呢?那不可能创建出2万个线程来为每个玩家服务，系统资源肯定会枯竭，程序崩溃。所以这种情况下，不可能每一个客户进来就创建一个线程，换句话说，在这种工作场景下，现在这种程序写法是行不通的。
2. 程序运行稳定性问题。不知道大家是否有一种感觉，写一个程序，如果这个程序中偶尔就有创建线程的代码出现，可以说这种程序的写法是有点让人不安的，创建线程这种代码相对于常规程序代码，对内存等硬件资源会有更多的消耗，线程的运行也需要CPU进行上下文切换，上下文切换必然要进行各种调度(如保存和恢复程序的现场数据)，所以这些消耗不能忽视。

创建线程既然有各种对系统资源的消耗问题，所以不排除，如果系统可用资源过低等一些不太常见的情况发生时，创建线程可能会失败，一旦创建线程失败，那该程序会不会因此而产生执行异常甚至崩溃?所以说，程序中偶尔在某种条件达成时就创建出来一个线程，这种程序写法是让人不安的，或者换句话说，就是写出来这个程序也总让人觉得心里没底，感觉不够稳定，尽管这种程序绝大部分时间工作起来都表现正常。

基于上面这些原因，也可能还存在一些这里没谈到的其他原因，开发者提出了“线程池”的概念。“池”这个字表示把一堆线程放到一起，进行统一的管理调度。发挥一下想象力，就是把多个线程放到一个池子里，用的时候随手抓一个线程拿来用，用完了再把这个线程扔回到池子里，供下次使用，也就是说循环再利用。这种统一的管理调度线程的方式，被形象地比喻为线程池。

### 实现方式

一般来讲，最简单的线程池实现方式，就是在程序启动的时候，一次性地创建好一定数量的线程，如少则可能10个8个，多则可能几十上百个(后续还会谈一些对线程创建数量的建议)。

当有一个任务请求(任务)到来的时候，就从线程池中拿出来一个预先创建好的但还没有分配任务的线程来处理任务请求，处理完任务请求后，线程不会销毁，会继续等待下次请求任务的到来。

那么请想一想，这种线程池的编码方式是不是更让人放心：程序开始执行的时候，就把线程预先创建好了，不会在程序执行过程中进行线程的创建和销毁工作，这样就不会因为动态创建线程导致瞬间占用更多系统资源，同时也提高系统运行效率(创建线程的开销比较大，对系统效率影响比较大)。此外，作为程序开发者，也能感觉到这种程序设计方式设计出的程序更健壮、稳定，更让人放心。

## 线程创建数量谈

### 线程创建的数量极限问题

很多人可能对一个程序(进程)里面到底能创建多少个线程感到好奇，其实这与很多因素有关，因为创建线程要消耗资源，不但是消耗内存，还有很多与操作系统相关的其他资源，这些资源的叫法可能对大家也不算太熟，在这里就不提了。根据相关人士的测试，一般开2000个左右线程就是极限，再创建就会导致资源枯竭甚至程序崩溃。

### 线程创建数量建议

这个问题比较重要，分两个方面谈：

1. 当程序员采用一些比较独特的开发技术来开发程序时，如采用IOCP完成端口技术开发网络通信程序，往往会收到开发接口提供商提出的建议，如建议创建的通信线程数量等于CPU数量、等于CPU的数量$*$2、等于CPU的数量$*$2+2等诸如此类。建议遵从这些建议，因为这些建议是专业的，经过大量测试的，有权威性。
2. 但如果某些线程是用来实现业务需求的，那么就要换个角度看问题。大家都知道，一个线程就等于一条执行通路，可以做个设想，例如这个系统要同时服务1000个客户，预计在最坏的情况下，可能会有100个用户同时充值，假如这个充值业务是给第三方充值服务器发起充值请求，并等待第三方充值服务器返回或者等待一个超时时间到来，这段时间可能短则几秒，长则几分钟，这个执行通路是堵着的，这意味着这个线程没有办法给其他用户提供服务，其他所有用户都要等待。

那请试想，如果这个系统中开启了110个线程，那么哪怕真有100个用户同时充值，堵在那里，还剩余10个线程可以为其他用户提供非充值业务的其他服务，所以这个时候，创建出来110个线程就显得非常必要。

有些人可能认为：何必创建110个线程，系统不是最大允许创建2000个线程吗?那直接创建1800个线程，留200个供将来扩展，1800个执行通路，可以同时应付1800个用户充值，这是不是更好?这当然不是更好。

其一：要知道，线程多的话，CPU在各个线程之间切换就要大量地保存数据和恢复数据，因为线程切换回来的时候要把线程中用到的如局部变量等数据也要恢复回来。显然，大量的保存和恢复数据是很占用CPU时间的，CPU都把时间花在保存和恢复数据上，它还有时间干正事吗?所以，当创建的线程数量过多时会发现，每个线程的执行都变得特别慢，整个系统的执行效率不升反降。

其二：现在的操作系统都是多任务操作系统，虽然系统会把一个应用程序虚拟成一个独立的个体，看起来所有硬件都归这个独立的个体所用，但是系统的硬件资源必定是有限的，一个程序占用的多了，另外一个程序必然就占用的少了，当程序运行所需的资源超出了整个计算机硬件的负荷，该计算机的运行效率就直线下降，程序执行将变得异常缓慢。

个人建议是，一个进程中所包含线程的数量尽量不要超过500个，以200个以内为比较好，就算是根据业务需要，一般来讲，也很少会用到超过200个线程的。如果业务太过庞大，单台计算机处理不了，那么就要考虑集群的解决方案，拼命榨取单计算机的硬件资源终究会有尽头。

到底创建多少个线程合适，一句话：实践是检验真理的最好标准。要根据不同的业务类型，找到创建工作线程的最佳数量。

## C++11多线程总结

传统上开发多线程程序的时候，不同的平台如Windows平台有自己的线程库开发接口(可以调用函数)， Linux平台也有自己的线程库开发接口，这些接口发展多年，成熟稳定，但是，因为它们不具备跨平台的特性，所以使用上多多少少会受到制约。

C++11中引入了多线程开发接口，从而使程序员脱离了以往在不同的操作系统平台下要用不同的线程库开发接口来实现多线程程序开发的尴尬境地，实现了可以通过C++语言本身提供的接口实现跨平台统一开发多线程程序的心愿，降低了学习成本，提高了程序的可移植性。

当然，当下C++11支撑的线程功能可能还不算太强大和成熟，但已经足够应付绝大部分开发需求了。同时，C++标准也在不断进化，所以有理由相信，C++对多线程的支持会越来越好，功能会越来越强大。

当然，也许开发中会遇到C++11标准线程库中的功能和具体操作系统平台相关线程开发接口结合使用的情形，这是很正常的，具体情况具体分析，结合使用可以优势互补，写出更好的多线程程序。