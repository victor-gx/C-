# 线程启动、结束与创建线程写法

## 范例演示线程运行的开始和结束

通过前面的学习已经知道，一个程序运行起来就生成了一个进程，该进程的运行也代表着该进程所属的主线程开始自动运行。主线程就从main主函数开始执行，如果main函数执行结束，也就是主线程运行结束，这意味着整个进程就运行结束了(也可以说这个程序运行结束)。

看看如下范例：

```c++
int main() {
	cout << "I love China!" << endl; //实际上这个就是主线程在执行,主线程从main函数返回,则整个进程执行完毕
	return 0;
}
```

上面这个程序很简单。下面写一个线程程序，自己创建一个线程(自己创建的线程可以称呼为子线程)。不难想象，程序运行起来后(进程)就有了一个自动生成的主线程，程序员再创建一个线程，这样这个程序运行起来后就会有两个线程，相当于这个程序有两条线在跑(主线程一条线，程序员创建的线程一条线)。

主线程是从main主函数开始执行的，自己创建的线程也得从一个函数(初始函数)开始执行，就好像主线程执行完main 主函数后会退出一样，自己创建的线程从某个函数开始执行，一旦这个函数执行完毕，那么自己创建的这个线程也就运行结束了。

但是这里要提醒大家的是，一般来讲，整个进程(程序)是否执行完毕的标志是主线程是否执行完，如果主线程执行完毕了，则整个程序(进程)就执行完毕了，此时，如果其他子线程没执行完毕，那么这些子线程也会被操作系统强制终止。这就得到一个结论：**如果想保持子线程一直处于运行状态，则必须要让主线程一直保持运行，千万不要让主线程运行完毕**(后面讲到detach时会打破这个规律，讲到时再细说)。

这里即将写一个自己的线程：

1. 在`MyProject. cpp`文件开始位置要`#include`一个头文件,这个头文件里包含了创建线程有关的函数声明信息：

   ```c++
   #include <thread>
   ```

2. 程序员创建的线程要从`myprint`函数开始运行，所以先完成这个函数：

   ```c++
   // 自己创建的线程也是从一个函数开始运行
   void myprint()
   {
   	cout << "我的线程开始执行了" << endl;
   	// ⋯⋯
   	cout << "我的线程执行完毕了" << endl;
   	return;
   }
   ```

3. 在main主函数中，加入如下代码：

   ```c++
   std::thread mytobj(myprint);		   // 这就是创建线程的代码,显然这是一个线程对象,然后给的参数是一个函数名，代表这个线程是从myprint这个函数(初始函数)开始运行
   mytobj.join();						   // join会卡在这里，等待myprint线程执行完毕，程序流程才会继续往下走
   cout << "main主函数执行结束!" << endl; // 这行由主线程执行,主线程从main返回,则整个进程执行完毕
   ```

执行起来，看一看结果：

```c++
我的线程开始执行了
我的线程执行完毕了
main主函数执行结束！
```

观察这个结果，仔细查看输出的信息顺序：先执行所创建线程对应的函数，然后执行`main`主函数中的cout语句输出`main主函数执行结束！`，最后整个程序结束。

现在必须明确一点，有两个线程在跑，相当于这个程序的执行有两条线在同时走，所以它可以同时做两件事情，即使一条线被堵住了，另外一条线还是可以通行，这就是多线程。

上面看到了几行新代码，介绍一下：

**thread**

```c++
std::thread mytobj(myprint); //创建一个线程，也可以称为创建一个子线程
```

`thread`是C++标准库里面的类，这个类就是用来创建线程的。可以看到，用这个类生成一个对象，名字为`mytobj`，里面是一个可调用对象(此处的可调用对象是函数`myprint`)作为`thread`构造函数的实参来构造这个`thread`对象。

这行代码一执行，新线程创建出来了，并且立即开始执行新线程的初始函数`myprint`。

**join**

```c++
mytobj. join();
```

从字面翻译来看， join的意思是“加入/汇合”。换句话说，就是“阻塞”的意思——主线程等待子线程执行完毕，执行流程最终汇合到一起(子线程执行完毕，执行流程回归主线程并执行完`main`主函数)。

所以，`join`成员函数的功能是：用来等待`myprint`函数(线程的入口函数，也就是代表自己创建的这个线程)运行完成。一旦执行了`join`这行代码，主线程就阻塞到这一行，等待`mytobj`对象所代表的线程执行完毕，也就是等待`myprint`函数执行完毕。

如果把`mytobj.join();`代码行注释掉,那么程序运行起来会报异常，而且程序的输出结果也是乱序的，例如可能是如下的输出结果：

```c++
main主函数执行结束！
我的线程开始执行了
我的线程执行完毕了
```

通过这个乱序结果不难发现，还没等子线程执行完毕，主线程先执行完毕了。这问题就来了，请想一想：子线程正在执行中(没执行完)，主线程执行完了，这会导致整个进程退出了。这样的程序代码是不稳定、不合格的，编写这样代码的程序员也是不称职的。

试想如果子线程正在写一个文件，主线程退出会导致整个程序的执行退出，那么，这个正在写文件的子线程就会被操作系统强行终止，这种强行终止很可能导致正在写的文件破损，变成废文件无法打开来使用。

所以，一个书写良好的程序，应该是主线程等待子线程执行完毕后，自己才能最终退出。这就是上面这条`join`语句的必要性。现在把`join`代码行的注释取消，再次看看结果。如下的结果顺序才是正确的：

```c++
我的线程开始执行了
我的线程执行完毕了
main主函数执行结束！
```

**detach**

刚才说过，主线程有义务等待所有子线程执行完毕后，自己才能最终退出。这是传统的多线程程序的写法。

但是随着语言的发展，也看到了打破传统的一些程序写法，这就是现在要介绍的`detach`成员函数。翻译成中文， detach是“分离”的意思。所谓分离，就是主线程不和子线程汇合了，主线程执行主线程的，子线程执行子线程的，主线程不必等子线程运行结束，可以先执行结束，这并不影响子线程的执行。

为什么会引入`detach`这样一个功能呢?说法就是：如果创建了很多子线程，让主线程逐个等待子线程结束，这种编程方法并不一定就是最好的，所以引入`detach`这种写法。

有的资料解释称，线程一旦`detach`后，那么与这个线程关联的`thread`对象就会失去与这个线程的关联(那当然了，因为`thread`对象是在主线程中定义的)，此时这个线程就会驻留在后台运行(主线程跟这个线程也就相当于失去联系了)，这个新创建的线程相当于被C++运行时库接管了，当这个线程执行完后，由运行时库负责清理该线程相关的资源。这种分离的线程作为开发Linux的读者可能比较熟悉它的名字——守护线程(大概守护进程更常听说)。

把上面的范例改造一下，看代码：

```c++
void myprint()
{
    cout << "我的线程执行完毕了1" << endl;
    cout << "我的线程执行完毕了2" << endl;
    cout << "我的线程执行完毕了3" << endl;
    cout << "我的线程执行完毕了4" << endl;
    cout << "我的线程执行完毕了5" << endl;
    cout << "我的线程执行完毕了6" << endl;
    cout << "我的线程执行完毕了7" << endl;
    cout << "我的线程执行完毕了8" << endl;
    cout << "我的线程执行完毕了9" << endl;
    cout << "我的线程执行完毕了10" << endl;
    return;
}
```

在`main`主函数中，删除以往代码，加入如下代码：

```c++
thread mytobj(myprint);
mytobj.detach(); // 加入detach后，程序也不再报异常，能正常运行
cout << "main主函数执行结束!" << endl;
```

这里多次执行，看一看结果，其实每次结果可能都有差别，不一样，多数情况下，输出结果为下面1行：

```c++
main主函数执行结束！
```

少数情况下，输出结果为下面2行甚至更多行：

```c++
main主函数执行结束！
我的线程执行完毕了1
```

可以看到，有时候看不到线程`myprint`输出的任何结果，有时候能看到`myprint`输出了1行结果(也可能更多行)，然后，因为主线程执行完毕，可执行程序(进程)退出执行，所以，`myprint`显示的结果也中断了，最终整个结果可能就1行(绝大多数情况下)，也可能是2行甚至更多行。也就是当主线程执行完毕，但`myprint`代表的子线程并没有执行完毕，而是转人后台去继续执行，因为主线程执行结束，当然也看不到这个转入到后台执行的`myprint`所输出的结果了(因为这个输出结果的窗口关联的是主线程)。

另外，值得提醒读者的是：针对一个线程，一旦调用了`detach`，就不可以再调用`join`了，否则会导致程序运行异常。

`detach`会导致程序员失去对线程的控制。所以在多数实际项目中， `join`更为常用，因为毕竟多数情况下程序员需要控制线程的生命周期，而创建一个线程并扔到后台不管的情况比较少。当然这也不是绝对的，如果子线程要做的事情和主线程没有直接关系，那么还是可以使用`detach`的。

**joinable**

判断是否可以成功使用join或者detach。(未调用join或detach为ture，否则为false)

如果在`main`主函数中，只有如下这样一条代码：

```c++
thread mytobj(myprint);
```

那么此时此刻，`joinable`返回的是`true`:

```c++
cout<< mytobj. joinable() <<endl; //1
```

但是如果随后调用了`join`或者`detach`，那么`joinable`会变成`false`。例如`main`主函数代码行修改为如下内容：

```c++
thread mytobj(myprint);
if (mytobj.joinable())
{
    cout << "1: joinable() == true" << endl; // 成立
}
else
{
    cout << "1: joinable() == false" << endl;
}
mytobj.join(); // 无论这里调用join()还是detach(),后续的joinable()都会返回false
if (mytobj.joinable())
{
    cout << "2: joinable() == true" << endl;
}
else
{
    cout << "2: joinable() == false" << endl; // 成立
}
```

所以，`joinable`有一定的用处——判断针对某个线程是否调用过`join`或者`detach`

```c++
if(mytobj.joinable()) //可以join的时候就join一下
mytobj.join(); //或者这里修改为mytobj.detach()也行
```

## 其他创建线程的写法

前面是用了一个函数`myprint`创建了一个线程，线程开启后直接执行`myprint`函数。那么既然`thread`类接受的是一个可调用对象作为参数来创建线程，那么，看一看换种写法来创建线程。

### 用类来创建线程

创建一个名字叫作`TA`的类：

```c++
class TA
{
public:
    // 15.3.3节提过的可调用对象：重载圆括号
    void operator()() // 不带参数
    {
        cout << " TA::operator()开始执行了" << endl;
        // ……
        cout << " TA::operator()执行结束了" << endl;
    }
};
```

在`main`主函数中，加入如下代码：

```c++
TA ta;
thread mytobj3(ta); // ta,可调用对象:这里不可以是临时对象thread mytobj3(TA());否则编译无//法通过
mytobj3.join();     // 为保证等待线程执行结束，这里使用join cout<<"main 主函数执行结束!"<<endl;
```

执行起来，结果一切正常。

另外，类与`detach`结合使用可能会带来意外问题。

修改`TA`类：

```c++
class TA
{
public:
    TA(int &i) : m_i(i) {}
    void operator()()
    {
        cout << "mi1的值为:" << m_i << endl; // 隐患，m_i可能没有有效值
        cout << "mi2的值为:" << m_i << endl;
        cout << "mi3的值为:" << m_i << endl;
        cout << "mi4的值为:" << m_i << endl;
        cout << "mi5的值为:" << m_i << endl;
        cout << "mi6的值为:" << m_i << endl;
    }
    int &m_i; // 引入一个引用类型的成员变量
};
```

在`main`主函数中，加入如下代码：

```c++
int myi = 6;
TA ta(myi);
thread mytobj3(ta); // 创建并执行子线程
mytobj3.detach();
cout << "main主函数执行结束!" << endl;
```

请注意，在类`TA`中，成员变量`m_i`是一个引用，绑定的是`main`主函数中的`myi`变量。所以，当主线程执行结束，很可能子线程在后台在继续运行，但是主线程结束时， `myi`会被销毁，子线程仍旧使用已经销毁的`myi`，产生不可预料的后果(也有可能执行时没啥异常表现，但始终是一颗定时炸弹)。这里读者可以通过打印类`TA`中`m_i`的地址来确定和`main`主函数中的 `myi` 地址相同来证明类`TA`中的成员变量`m_i`绑定的是 `main` 主函数中的 `myi `。

当然，还有个疑问：一旦在`main`主函数中`detach`，那么主线程执行结束后， `main`主函数中的`ta`对象会被销毁，那么，子线程中看起来正在使用这个`ta`对象，如果被主线程销毁，是否会出现问题呢？其实，` ta`对象是会被复制到子线程中。所以，虽然执行完主线程后， `ta`对象被销毁，但复制到子线程中的对象依旧存在，所以这不是问题。但是，这个对象中如果有引用或者指针，那就另当别论了，那就可能产生问题。

为了进一步演示，给`TA`类的构造函数增加一行输出语句，并增加`public`修饰的析构函数和拷贝构造函数：

```c++
TA(int &i) : m_i(i)
{
    printf("TA()构造函数执行, m_i=%d, this=%p\n", m_i, this);
}
~TA()
{
    printf("~TA()析构函数执行, m_i=%d, this=%p\n", m_i, this);
}
TA(const TA &ta) : m_i(ta.m_i)
{
    printf("TA()拷贝构造函数执行, m_i=%d, this=%p\n", m_i, this);
}
```

执行起来，看一看结果(注意：多次执行结果可能不一样，但至少会有4行输出结果)：

```c++
TA()构造函数执行,m_i=6, this=00EFFAF0
TA()拷贝构造函数执行,m_i=6,this=01150550
main主函数执行结束！
mi1的值为:~TA()析构函数执行,m_i=6, this=00EFFAF0
```

通过结果可以看到，`TA`类的拷贝构造函数执行了一次，这说明`ta`对象被复制到线程(程序员创建的子线程)中去了。主线程执行完毕后，此时子线程并没有执行完毕，所以从主线程中可以看到，只执行了一次`TA`析构函数，就是针对`ta`对象的析构，而另外一个用拷贝构造函数复制到线程中去的对象，因为主线程的退出导致子线程已经跑到后台去了，所以子线程中用到的对象的析构函数的输出结果并不会显示到屏幕上(主线程的退出导致屏幕上无法看到子线程的后续输出结果)。

当然，如果`main`主函数中不用`detach`，而用`join`，那就可以看到完整的输出结果(包括主线程和子线程的)。`main`主函数中代码如下：

```c++
int myi = 6;
TA ta(myi);
thread mytobj3(ta); // 创建并执行子线程
// mytobj3. detach( );
mytobj3.join();
cout << "main主函数执行结束!" << endl;
```

执行起来，看一看结果：

```c++

```

从结果不难看到，先释放复制到线程里面去的`ta`对象(注意`this`值)，因为`main`中的代码一直在`join`行等待子线程执行完毕，子线程执行完，当然会先把子线程的对象释放(析构)，然后最后一行释放的才是主线程的`ta`对象。请读者注意比较构造和析构函数输出结果中的`this`值，这样就能够正确地匹配构造和析构函数的输出结果行。例如上面结果中，下面两行是一对，因为`this`值相同：

```c++
TA()构造函数执行,m_i=6,this=00AFF8A4
~TA()析构函数执行,m₋i=6,this=00AFE8A4
```

而下面两行因为this值相同，也是一对：

```c++
TA()拷贝构造函数执行,m_i=6, this=00D4DF98
~TA()析构函数执行,m₋i=6,this=00D4DF98
```

还有一个值得注意的问题就是`TA`类中的`m_i`成员变量。为了保证 `detach` 能够正常地运行(保证不存在任何隐患)，所以`TA`类中`m_i`成员变量不应该是一个引用类型，而应该是一个正常的`int`类型修改一下类`TA`中的内容：

```c++
public:
    TA(int i) : m_i(i)
    {
        printf("TA()构造函数执行, m_i=%d, this=%p\n", m_i, this);
    }

public:
    int m_i;
```

经过了上面的修改，则在`main`主函数中,无论调用`mytobj3.join();`还是`mytobj3.detach();`都可以保证程序安全健壮地运行。

### 用lambda表达式来创建线程

修改`main`函数中的代码如下：

```c++
auto mylamthread = []
{
    cout << "我的线程开始执行了" << endl;
    // ⋯⋯
    cout << "我的线程执行完毕了" << endl;
};
thread mytobj4(mylamthread);
mytobj4.join();
cout << "main主函数执行结束!" << endl;
```

执行起来，看一看结果：

```c++
我的线程开始执行了
我的线程执行完毕了
main主函数执行结束！
```

上面这段代码和执行的结果非常简单，就不多解释。