# 单例设计模式共享数据分析、解决与 call_once

前面讲解了互斥量，互斥量是最通用的保护共享数据的机制。但是也有其他的保护共享数据的机制。

## 设计模式简单谈

“设计模式”在前些年是非常流行的一个术语，设计模式就是开发程序的一些代码写法(这些写法往往比较特别，与常规写法不同)，运用了这些代码写法的程序，其特点就是程序写起来比较灵活(增加或者减少某些功能不会牵一发而动全身)，但如果全面接管和掌控运用设计模式所书写的项目，会感觉非常痛苦(例如常规下1个类就能实现的功能，运用设计模式后可能需要3~5个类才能实现)。

用设计模式书写的程序有点像变形金刚。变形金刚全身每个零件都能动，都灵活，所以它变形、扩展都方便，但制作、研究其结构、组装它的人一定是很痛苦的。

用设计模式理念写出来的代码确实是很晦涩的，但国内有那么一个阶段，非常流行设计模式，面试必考，那个时候被面试的人要是一口气不说出10个或8个设计模式，那工作都找不到，谈到写程序必然谈到设计模式。

设计模式，其实是国外的开发者应付特别大的项目时把项目的开发经验、模块划分经验等总结起来构成的一系列开发技巧(先有开发需求，后有理论总结和整理)。不过这件事情拿到国内来就有点不太一样了，很多人拿着程序硬往设计模式上套，一个小小的项目非要用几个设计模式进去，本末倒置，与推出设计模式的初衷完全相反。

设计模式有它独特的优点，但读者如果接触到设计模式，还是应该活学活用，不要深陷其中，生搬硬套，这对程序员的成长弊大于利。

## 单例设计模式

其中有一种设计模式叫单例模式，使用频率比较高。什么叫单例呢？就是整个项目有某个或者某些特殊的类，属于该类的对象，只能创建一个，无法创建多个。

例如以往有个类`A`：

```c++
class A
{
public:
} ;
```

要创建属于该类的对象，则愿意创建几个就创建几个，没有什么限制。例如，创建两个`A`类对象`a1`和`a2`，这是完全可以的。代码如下：

```c++
A a1;
A a2;
```

但是，单例类特殊在只能创建该类的一个对象(后面会有演示)，整个项目中就用这一个对象来进行各种相关操作。为什么说单例模式使用频率比较高呢？例如做一些配置文件的读写等工作，整个项目中用这一个对象操作就够用了，根本不需要创建多个相同类型的对象。

有一个项目，参与开发者分别是张三、李四、王五，现在张三开发了一个和配置文件相关的类，但是张三不希望李四、王五生成这个类的很多对象去操作这个配置文件，因为不但没这个必要，而且代码管理起来也很混乱，容易出问题，所以张三就把这个配置文件相关的类写成了一个单例类。

现在写一个单例类，请注意看代码，看看用C++如何写一个比较实用的单例类。这段代码也许读者在日后的工作中能够拿来商用，请注意代码积累。

类`MyCAS`可以写在`MyProject. cpp`的上面，代码如下：

```c++
class MyCAS // 这是一个单例类
{
private:
    MyCAS() {} // 构造函数是私有的
private:
    static MyCAS *m_instance;

public:
    static MyCAS *GetInstance()
    {
        if (m_instance == NULL)
        {
            m_instance = new MyCAS();
            static CGarhuishou cl; // 生命周期一直到程序退出
        }
        return m_instance;
    }
    class CGarhuishou // 类中套类，用于释放对象
    {
    public:
        ~CGarhuishou()
        {
            if (MyCAS::m_instance)
            {
                delete MyCAS::m_instance;
                MyCAS::m_instance = NULL;
            }
        }
    };
    void func() // 普通成员函数，方便做一些测试调用
    {
        cout << "测试" << endl;
    }
};
```

接着，要对静态成员变量`m_instance `定义和初始化一下。接着上述类`MyCAS`定义代码行的下面继续写：

```c++
MyCAS *MyCAS::m_instance = NULL; // 类静态成员变量定义并初始化
```

上面是一段比较精巧的代码，值得仔细阅读和分析，注意看它是怎样new，怎样delete的，尤其是delete的技巧，是比较不常见到的。

注意到该类的构造函数是用private修饰的，这样就不能创建基于该类的对象了。例如下面的代码都将无法编译通过，这正是单例类要达到的效果。

```c+++
MyCAS a1; //非法
MyCAS *pa = new MyCAS(); //非法
```

那么，在`main`主函数中，如何创建这个单例类的对象呢？在`main`主函数中，加入如下代码：

```c++
MyCAS *p_a = MyCAS::GetInstance(); // 创建单例类MyCAS类的对象
p_a->func();                       // 一条测试语句，用于打印结果
MyCAS::GetInstance()->func();      // 这种写法的测试语句也可以打印结果
```

执行起来，看一看结果：

```c++
测试
测试
```

从结果中可以看出，运行一切正常。

在这里有个疑问：这个单例类对象所占用的内存在程序退出时会主动释放吗？会主动释放的(当然，不主动释放等待程序运行结束时由操作系统来回收也可以，但主动释放是一个更好的习惯)。可以把程序断点设置在如下代码行：

```c++
delete MyCAS::m_instance;
```

跟踪调试，当整个程序结束的时候，上面代码行会被执行，从而在程序结束之前，主动释放单例类对象的内存空间(这样程序退出时就不会造成任何内存泄漏)。可以以`static CGarhuishou cl;`代码行为突破口，分析一下上面这行`delete`代码是如何被执行的。

这里简单说一下该单例类对象在程序运行结束时的释放原理。因为`cl`是一个静态成员变量，其生命周期会一直持续到整个程序的退出，当整个程序退出的时候，会调用`cl`所属类(`CGarhuishou`)的析构函数，在该析构函数中释放该单例类对象的内存。

## 单例设计模式共享数据问题分析、解决

接下来可能要面临一个问题，就是这个单例类可能会被多个线程使用，如果能够做到这个单例类中的数据被初始化完之后是只读的，那么不要紧，只读数据是可以被多个线程同时读的，不需要互斥。

在上面的代码中，这个单例类对象的创建是在主线程中完成的，这没有什么问题，而且在主线程中并在所有其他子线程创建并运行之前创建`MyCAS`单例类对象的做法是笔者强烈推荐的。因为这个时候不存在多线程对这个单例类对象访问的冲突问题。如果这个单例类对象还需要从配置文件中装载数据，那么也可以在这个时机把所有该装载的文件数据都装载进来。这样如果以后在所有其他线程中都只需要从这个单例类中读共享数据，那么在多个线程中访问(读)这些共享数据都不需要加锁，可以随意随时读。

但是并不排除，在实际项目中可能会面临着需要在程序员自己创建的线程(而不是主线程)中创建`MyCAS`单例类对象，而且程序员自己创建的线程可能还不是1个，而是至少2个，也就是说，这段创建`MyCAS`单例类对象的代码(`GetInstance`)可能需要做互斥。看看如下这种写法。

在`lesson7.cpp`的上面增加如下线程入口函数:

```c++
void mythread()
{
    cout << "我的线程开始执行了" << endl;
    MyCAS *p_a = MyCAS::GetInstance(); // 在这里初始化就很可能出现问题
    cout << "我的线程执行完毕了" << endl;
    return;
}
```

在`main`主函数中删除以往代码，加入如下代码：

```c++
std::thread mytobj1(mythread);
std::thread mytobj2(mythread);
mytobj1.join();
mytobj2.join();
```

虽然这两个线程用的是同一个线程入口函数，但这是两个线程，所以有可能会有两个流程(两条通路)同时开始执行`mythread`线程入口函数。

在线程中调用如下代码初始化就可能出现问题：

```c++
MyCAS *p_a = MyCAS::GetInstance();
```

试想这种可能，线程1刚要执行如下行：

```c++
m_instance = new MyCAS();
```

操作系统突然切换到线程2，线程2判断 `if(m_instance == NULL)`条件成立，则线程2也要执行如下行：

```c++
m_instance = new MyCAS();
```

当线程2把上面这行执行完毕后，操作系统又切换回线程1继续执行，导致第一个线程执行了一次`m_instance = new MyCAS();`。

这样看起来，`m_instance = new MyCAS();`其实是被执行了两次(每个线程各执行了一次)。

这就有问题了，尽管每个线程分别`new MyCAS`对象一次的情况很少出现(多次执行这个可执行程序才有可能碰到这里描述的情形)，但毕竟是有概率发生的。这个时候，大家可能马上就想到解决办法了：使用一个互斥量来解决不就可以了嘛！好，加个互斥量看一看。

在类`MyCAS`定义的前面，增加一个全局互斥量：

```c++
std::mutex resource_mutex;
```

然后，就要修改一下`MyCAS`类里的`GetInstance`成员函数，把这个互斥量用进去。修改后的代码如下：

```c++
static MyCAS *GetInstance()
{
    std::unique_lock<std::mutex> mymutex(resource_mutex); // 自动加锁
    if (m_instance == NULL)
    {
        m_instance = new MyCAS();
        static CGarhuishou cl; // 生命周期一直到程序退出
    }
    return m_instance;
}
```

说到这里，也许一些读者认为这个话题就结束了。其实没有结束，因为这样写程序，肯定会被高手不屑或被项目经理痛骂。在其他线程中可能需要用到这个单例类对象，而且在实际项目中，也可能会频繁地在许多这个或者那个线程中不停地调用`MyCAS::GetInstance`函数，因为只有通过(借助)`GetInstance`成员函数才能获取单例类`MyCAS`的对象从而能够调用到`MyCAS`中的成员函数。例如，若想调用`MyCAS`类中的`func`成员函数，就要写下面这样的代码：

```c++
MyCAS *p_a = MyCAS::GetInstance();
p_a->func( );
```

那么，在`GetInstance`成员函数中，就为了解决一个初始化该类对象时的互斥问题，居然在`GetInstance`中增加互斥量，导致所有调用该函数的调用者线程都被互斥一下，这非常影响性能。因为除了初始化那个时刻，其他的时候完全不需要互斥。一旦初始化完毕，不管是否互斥调用`GetInstance`，这个`if(m_instance==NULL)`条件都不会成立，从而完全可以确保初始化完毕之后，`m_instance = new MyCAS();`代码行绝不会被再次执行。

所以，把互斥量写在这里非常影响效率。那怎样改进呢？看一看笔者写的改进代码：

```c++
static MyCAS *GetInstance()
{
    if (m_instance == NULL)
    {
        std::unique_lock<std::mutex> mymutex(resource_mutex); // 自动加锁
        if (m_instance == NULL)
        {
            m_instance = new MyCAS();
            static CGarhuishou cl; // 生命周期一直到程序退出
        }
    }
    return m_instance;
}
```

可以注意到，在上面多包了一层`if(m_instance==NULL)`也就是有两个 `if(m_instance== NULL)`，许多资料上叫这种写法为“双重锁定”或者“双重检查”。

第一次看到这种代码可能不太习惯，也不太理解为什么要多包一层 `if(m_instance==NULL)`，其实就是为了提高效率而采用的一种代码书写手段。这里解释一下：

1. 必须要承认一点：如果条件 `if(m_instance != NULL)`成立，则肯定代表`m_instance`已经被`new`过了。
2. 如果条件` if(m_instance == NULL)`成立，不代表`m_instance` 一定没被 `new` 过，因为很可能线程1刚要执行`m_instance = new MyCAS();`代码行，就切换到线程2去了(结果线程2可能就会`new`这个单例对象)，但是一会切换回线程1时，线程1会立即执行`m_instance = new MyCAS();`来 `new` 这个单例对象(结果 `new` 了两次这个单例对象)。

所以` if(m_instance == NULL)`成立，不代表`m_instance` 一定没被`new`过。

那么，在`m_instance` 可能被 `new` 过(也可能没被 `new` 过)的情况下，再去加锁。加锁后，只要这个锁能锁住，那再次判断条件 `if(m_instance == NULL)`，如果这个条件依然满足的话，那肯定表示这个单例类对象还没有被初始化，这个时候就可以放心地用`new`来初始化。

例如，线程1马上要执行代码行`m_instance = new MyCAS();`时，一下切换到线程2去了，那线程2拿不到锁它就要卡在那里(此时又会自动切换回线程1)，等线程1执行完`new` 的操作，然后释放了锁，线程2拿到锁，此时线程再判断` if(m_instance == NULL)`条件肯定就不成立了。

那平时常规调用`GetInstance`的时候，因为最外面有一个条件判断`if(m_instance == NULL)`在，这样就不会每次调用`GetInstance`创建一次互斥量。也就是说，平常的调用根本就执行不到创建互斥量的代码，而是直接执行`return m_instance;`，这样调用者就能够直接拿到这个单例类的对象，所以肯定提高了执行`GetInstance`的效率。

说到这里，这个话题其实就可以告一段落了。因为这段代码的效率也可以说还是可以的：因为只有初始化单例类对象的时候临界一下，其他常规调用都不需要临界。

## std:: call_once

这里借着刚才所讲述的案例，顺便简单讲解一下` call_once` 的用法。这是一个C++11引入的函数，这个函数的第二个参数是某个其他的函数名。

假设有个函数，名字为`a`，`call_once` 的功能就是能够保证函数`a`只被调用一次。例如有两个线程都调用函数`a`，那么这个函数`a`肯定是会被调用两次。但是，有了`call_once`，就能保证，即便是在多线程下，这个函数`a`也只会被调用一次。如果把刚才的单例类对象的初始化代码放到这种只被调用一次的函数`a`里，是不是也能解决刚才所面对的单例对象在多线程情况下初始化需要互斥的问题。

所以从这个角度讲， `call_once` 也是具备互斥量的能力的，而且效率上据说比互斥量消耗的资源更少。

引入 `std::once_flag`，这是一个结构，在这里就理解为一个标记即可，` call_once` 就是通过这个标记来决定对应的函数`a`是否执行，调用 `call_once` 成功后， `call_once` 会反转这个标记的状态，这样再次调用 `call_once` 后，对应的函数`a`就不会再次被执行了。

下面改造一下代码。首先定义一个全局量如下：

```c++
std::once_flag g_flag; // 这是一个系统定义的标记
```

在`MyCAS`类定义中,增加如下`private`修饰的成员函数`CreateInstance`：

```c++
static void CreateInstance()
{
    // 如下两行是测试代码
    //std::chrono::milliseconds dura(20000); //1s = 1000ms,所以20000ms= 20s
    //std:: this_thread:: sleep_for( dura);//休息一定的时长
    m_instance = new MyCAS();
    cout << "CreateInstance()执行完毕"; // 测试用
    static CGarhuishou cl;
}
```

然后也要重新修改`GetInstance`成员函数：

```c++
static MyCAS *GetInstance()
{
    std::call_once(g_flag, CreateInstance); // 两个线程同时执行到这里时,其中一个线程卡在//这行等另外一个线程的该行执行完毕(所以可以把g_flag 看成一把锁)
    return m_instance;
}
```

通过设置断点、跟踪调试以及在`CreateInstance`中增加 `std:: this_thread:: sleep_for` 等手段，调试程序可以发现，当两个线程同时执行到代码行 `std::call_once` 的时候，只有一个线程真正进入了对`CreateInstance`的调用中去了，此时，另外一个线程卡在 `std::call_once`所在行处于一直等待中。当进入`CreateInstance`的线程返回时，`g_flag` 标记被设置，这个设置导致卡在 `std::call_once` 行的另一个线程不会再去调用`CreateInstance`函数，从而保证即便是有多个线程存在，但对`CreateInstance`函数的调用只有一次，从而确保了单例类对象只会被 `new` 一次(`m_instance = new MyCAS();`代码行只会被执行一次)。再调整一下`GetInstance`的写法，加一个条件判断，是否可以让效率再提高一点：

```c++
static MyCAS *GetInstance()
{
    if (m_instance == NULL) // 同样为提高效率
    {
        std::call_once(g_flag, CreateInstance);
    }
    return m_instance;
}
```

最后值得再次说明的是，虽然本节讲的还是多线程互斥的话题，但是针对这种单例类对象的初始化工作，强烈建议放在主线程中其他子线程创建之前进行，这样当各个子线程开始工作时，单例类对象已经创建完毕，就完全不必要在`GetInstance`成员函数中考虑多线程调用时的互斥问题，只需要像本节最初那样书写`GetInstance`版本代码行即可。也就是下面这个版本：

```c++
public:
    static MyCAS *GetInstance()
    {
        if (m_instance == NULL) // 在主线程中其他子线程创建之前创建单例类对象，完全不必考//虑多线程互斥问题
        {
            m_instance = new MyCAS();
            static CGarhuishou cl; // 生命周期一直到程序退出
        }
        return m_instance;
    }
```

